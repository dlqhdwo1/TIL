
## 1. 데이터베이스 

### 특성

1.실시간 접근성

2.동시성

3.일관성

4.무결성

5.데이터 중복 최소화

6.보안성

7.독립성 


### 데이터베이스 모델링

- 실제 데이터베이스를 만들기 전에 구조를 설계하는 과정.

- 1단계 : 개념적모델링 무엇을 저장할지 정리하는 단계 , ERD다이어그램이 많이 사용됨.
- 2단계 : 논리적모델링 개념적 모델링을 기반으로 릴레이션 스키마 형태로 구체화.
- 3단계 : 물리적모델링 논리적모델을 실제 데이터베이스에 적용하는 단계
        : DBMS에 맞는 데이터 타입, 인덱스, 제약 조건 설정


### 정규화

- 이상현상 : 정규화를 하지 않으면 데이터 수정, 삽입 , 삭제시 문제가 발생.
- 삽입이상 : 데이터를 삽입할때 불필요한 데이터까지 입력해야 하는 문제
- 수정이상 : 중복된 데이터가 존재할 경우, 하나만 수정하면 데이터 불일치가 발생하는 문제
- 삭제이상 : 하나의 데이터를 삭제할때 연관된 다른 데이터까지 삭제되는 문제

- 정규화 : 데이터베이스 설계에서 중복을 최소화하고 데이터 무결성을 유지하기 위한 과정.

- 과도한 정규화는 JOIN연산이 많아져 성능 저하를 유발할수있음.


### 정규화 단계

- 제1정규형 : 각 컬럼이 하나의 원자값(하나의 값)만 가져야 한다는 규칙.
- 제2정규형 : 부분 함수 종속 제거 1NF를 만족하고, 기본키의 일부만으로 특정 컬럼이 결정되는 경우 제거
- 제3정규형 : 2NF를 만족하면서 이행적 종속을 제거하는 과정 


### 트랜잭션

- 트랜잭션 : 데이터베이스에서 하나의 논리적 작업 단위를 의미.
           : 모든 작업이 성공해야만 최종적으로 반영되고, 하나라도 실패하면 전체 작업이 취소(RollBack)됨.
           : 데이터의 일관성을 유지하기 위해 사용됨.

- 특성
  - 원자성 : 트랜잭션 내의 모든 작업은 모두 성공 or 모두 실패
  - 일관성 : 트랜잭션 실행되기 전과 후의 데이터가 일관성을 유지해야 함.
  - 고립성 : 여러 트랜잭션이 동시에 실행될 때 서로 영향을 주지 않아야함.
  - 지속성 : 트랜잭션이 완료되면 그 결과가 영구적으로 반영되어야 함.
 
- 상태
  - Active(활성상태) : 트랜잭션이 시작되어 실행 중인 상태
  - Partially Committed(부분 완료 상태) : 트랜잭션이 모든 SQL문을 실행했지만 아직 확정(commit)되지 않은 상태
  - Committed(완료상태) : 트랜잭션이 성공적으로 완료되어 데이터가 영구적으로 반영된 상태
  - Failed(실패상태) : 오류로 인해 트랜잭션이 정상적으로 완료되지 못한 상태
  - Aborted(중단상태) : 트랜잭션이 실패하며 ROLLBACK이 수행된 상태
 

### 트랜잭션 복구

- 지연갱신방식 : 트랜잭션의 작업 내용을 로그에만 기록하고, 실제 DB 반영은 COMMIT 이후에 수행함.
- 장애 발생 시, COMMIT된 트랜잭션만 반영하면 됨 -> Redo연산 사용
- COMMIT되지 않은 트랜잭션은 무시하면 됨
- Redo연산
  - COMMIT된 트랜잭션이 장애로 인해 DB에 반영되지 못했을 경우, 트랜잭션 로그에 따라 다시 반영하는 작업
  - 트랜잭션 로그에 기록된 값을 DB에 반영함 

### 트랜잭션 격리수준
- 트랜잭션 격리 수준
  - 하나의 트랜잭션에서 작업중인 데이터가 다른 트랜잭션에 영향을 받지 않는 정도를 의미.
  - 반대로 하나의 트랜잭션에서 작업중인 데이터를 다른 트랜잭션에서 어느 정도까지 접근할 수 있는가를 나타냄

- 트랜잭션 격리 수준의 설정
  -격리 수준을 낮게 설정하면 동시성이 좋아짐.
  -격리 수준을 높에 설정하면 동시성은 떨어지지만 정확성이 좋아짐.
  -따라서 둘 사이의 trade-off를 고려해야한다.


- 1단계(READ UNCOMMITTED)
  - COMMIT되지 않은 데이터를 읽을 수 있음.
  - Dirty Read 발생 가능
- 2단계(READ COMMITTED)
  - COMMIT된 데이터만 읽을 수 있음.
  - Dirty Read를 방지하지만, Non-Repeatable Read 발생 가능.
- 3단계 (REPEATABLE READ)
  - 같은 데이터를 조회하면 항상 같은 결과 반환(트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회).
  - Non-Repeatable Read를 방지하지만, Phantom Read 발생 가능.
- 4단계(SERIALIZABLE)
  - 모든 문제 방지(가장 강력한 격리 수준)
  - 각 트랜잭션이 마치 하나씩 순서대로 실행된 것처럼 보이게 동  

### 인덱스 
- 인덱스란?
  - 인덱스(Index)
    - 데이터베이스에서 검색 속도를 향상시키기 위한 자료구조
  - 클러스터형 인덱스
    - 데이터 자체가 인덱스 순서대로 저장됨.
    - 검색이 빠르지만, 삽입/삭제시 재정렬 필요.
    - 기본키에 자동으로 생성되며, 테이블당 하나만 존재 가능.
  - 비클러스터형 인덱스
    - 기본키 이외의 컬럼에서 검색 속도를 높이기 위해 사용됨.
    -  인덱스와 실제 데이터가 따로 저장되므로, 조회시 한단계 더 검색해야함.
    -  인덱스 전용 테이블이 별도로 생성

### 인덱스의 자료구조
  - 데이터베이스 인덱스는 검색 성능을 높이기 위해 특정한 자료구조를 사용
  - 대표적으로 B-Tree , B+Tree
  - B-Tree
    - 모든 노드에 데이터 저장.
    - 전체 데이터를 여러 노드에 분할해 저장.
  - B+Tree
    - 리프노드가 연결리스트 형태로 구성되고, 리프 노드에만 데이터를 저장하여 범위 검색이 빠름. 

### 복합인덱스
  - 복합 인덱스
    - 여러 개의 컬럼을 하나의 인덱스로 묶어서 생성하는 인덱스
    - 하나의 인덱스로 여러 컬럼을 동시에 검색할 때 성능을 최적화함.
  - 복합 인덱스 사용 이유
    - WHERE 조건에서 여러 개의 컬럼을 함께 검색하는 경우 속도를 최적화하기 위해 사용
    - 하나의 인덱스를 사용하여 여러 조건을 동시에 만족하는 데이터를 빠르게 찾을 수 있음.
   
### 샤딩,파티셔닝
 -샤딩
   - 데이터를 여러 개의 독립적인 데이터베이스로 나누어 저장

 - 파티셔닝
   - 하나의 데이베이스 내에서 데이터를 여러 개의 파티션으로 분할
   - 샤딩과 다르게 물리적으로 데이터베이스를 나누는 것이 아니라, 논리적으로 하나의 테이블을 여러 개의 파티션으로 나누는 방 
                    
